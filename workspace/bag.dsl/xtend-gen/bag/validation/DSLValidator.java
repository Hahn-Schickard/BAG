/**
 * generated by Xtext 2.17.0
 */
package bag.validation;

import bag.model.bagEcore.App;
import bag.model.bagEcore.Characteristic;
import bag.model.bagEcore.MacAddress;
import bag.model.bagEcore.MacFilter;
import bag.model.bagEcore.Sensor;
import bag.model.bagEcore.Service;
import bag.validation.AbstractDSLValidator;
import java.util.HashSet;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class DSLValidator extends AbstractDSLValidator {
  public static final String UNIQUE_NAME = "uniqueName";
  
  public static final String WHITESPACE = "whitespace";
  
  public static final String MACADDRESS = "macAddress";
  
  /**
   * Validation rule to check if every given name of an element is unique. There shouldn't be any duplicate 'Service', 'Characteristic' or 'UiElement' names.
   */
  @Check
  public void uniqueNameService(final Sensor sensor) {
    final Set<String> duplicateServices = new HashSet<String>();
    final Set<String> duplicateCharacteristic = new HashSet<String>();
    final Set<String> duplicateUiElements = new HashSet<String>();
    EList<Service> _service = sensor.getService();
    for (final Service service : _service) {
      {
        boolean _add = duplicateServices.add(service.getName());
        boolean _not = (!_add);
        if (_not) {
          String _name = service.getName();
          String _plus = ("Duplicate service name: " + _name);
          this.error(_plus, null, DSLValidator.UNIQUE_NAME);
        }
        EList<Characteristic> _characteristic = service.getCharacteristic();
        for (final Characteristic characteristic : _characteristic) {
          {
            boolean _add_1 = duplicateCharacteristic.add(characteristic.getName());
            boolean _not_1 = (!_add_1);
            if (_not_1) {
              String _name_1 = characteristic.getName();
              String _plus_1 = ("Duplicate characteristic name: " + _name_1);
              this.error(_plus_1, null, DSLValidator.UNIQUE_NAME);
            }
            boolean _add_2 = duplicateUiElements.add(characteristic.getUielement().getName());
            boolean _not_2 = (!_add_2);
            if (_not_2) {
              String _name_2 = characteristic.getUielement().getName();
              String _plus_2 = ("Duplicate uielement name: " + _name_2);
              this.error(_plus_2, null, DSLValidator.UNIQUE_NAME);
            }
          }
        }
      }
    }
  }
  
  /**
   * Validation rule to check element names for not allowed whitespace. There shouldn't be any whitespace in 'PackageName', 'Service'-name, 'Service'-uuid,
   * 'Characteristic'-name, 'Characteristic'-uuid and 'UiElement'-name.
   */
  @Check
  public void noWhitespaces(final App app) {
    boolean _contains = app.getPackageName().contains(" ");
    if (_contains) {
      String _packageName = app.getPackageName();
      String _plus = ("Package name: \"" + _packageName);
      String _plus_1 = (_plus + "\" contains a not allowed whitespace");
      this.error(_plus_1, null, DSLValidator.WHITESPACE);
    }
    EList<Service> _service = app.getSensor().getService();
    for (final Service service : _service) {
      {
        boolean _contains_1 = service.getName().contains(" ");
        if (_contains_1) {
          String _name = service.getName();
          String _plus_2 = ("Service name: \"" + _name);
          String _plus_3 = (_plus_2 + "\" contains a not allowed whitespace");
          this.error(_plus_3, null, DSLValidator.WHITESPACE);
        }
        boolean _contains_2 = service.getUuid().contains(" ");
        if (_contains_2) {
          String _uuid = service.getUuid();
          String _plus_4 = ("Service uuid: \"" + _uuid);
          String _plus_5 = (_plus_4 + "\" contains a not allowed whitespace");
          this.error(_plus_5, null, DSLValidator.WHITESPACE);
        }
        EList<Characteristic> _characteristic = service.getCharacteristic();
        for (final Characteristic characteristic : _characteristic) {
          {
            boolean _contains_3 = characteristic.getName().contains(" ");
            if (_contains_3) {
              String _name_1 = characteristic.getName();
              String _plus_6 = ("Characteristic name: \"" + _name_1);
              String _plus_7 = (_plus_6 + "\" contains a not allowed whitespace");
              this.error(_plus_7, null, DSLValidator.WHITESPACE);
            }
            boolean _contains_4 = characteristic.getUuid().contains(" ");
            if (_contains_4) {
              String _uuid_1 = characteristic.getUuid();
              String _plus_8 = ("Characteristic uuid: \"" + _uuid_1);
              String _plus_9 = (_plus_8 + "\" contains a not allowed whitespace");
              this.error(_plus_9, null, DSLValidator.WHITESPACE);
            }
            boolean _contains_5 = characteristic.getUielement().getName().contains(" ");
            if (_contains_5) {
              String _name_2 = characteristic.getUielement().getName();
              String _plus_10 = ("UiElement name: \"" + _name_2);
              String _plus_11 = (_plus_10 + "\" contains a not allowed whitespace");
              this.error(_plus_11, null, DSLValidator.WHITESPACE);
            }
          }
        }
      }
    }
  }
  
  /**
   * Validation rule to check if the defined MAC-address matches the common pattern 'XX:XX:XX:XX:XX:XX'.
   */
  @Check
  public void macAddressForm(final App app) {
    MacFilter _macfilter = app.getMacfilter();
    boolean _tripleNotEquals = (_macfilter != null);
    if (_tripleNotEquals) {
      EList<MacAddress> _macaddress = app.getMacfilter().getMacaddress();
      for (final MacAddress macAddress : _macaddress) {
        boolean _matches = macAddress.getAddress().matches("^([0-9A-Fa-f]{2}[:]){5}([0-9A-Fa-f]{2})$");
        boolean _not = (!_matches);
        if (_not) {
          String _address = macAddress.getAddress();
          String _plus = ("MacAddress : \"" + _address);
          String _plus_1 = (_plus + "\" did not match required pattern XX:XX:XX:XX:XX:XX");
          this.error(_plus_1, null, DSLValidator.MACADDRESS);
        }
      }
    }
  }
}
